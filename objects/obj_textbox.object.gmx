<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_textbox</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1410065407</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//sets the variables for:
//text_to_draw = which text is being drawn
//arrow_drawer = whether the arrow is on or not
//chr_ = which character of text being drawn is currently the last
//skipchr notes how many characters for the command editor to skip
//speed_mode is the speed that the text will be written
//(default speed_mode is 3)
//sound_type is the "voice" for the current character speaking
//(default sound_type is snd_voicemid)
//scr_stredit sets up the edited text for writing effects
//shaking tells whether or not the screen shaking effect is on
//view_xstart and view_ystart keep track of the screen shaking
//namebox_size is the size of the namebox
//command checks if the current character is a command character
//sliding makes the textbox slide on/off screen
//text_option is for prompts in the textbox
//option_text is what text the options give
//goto_text is which text_id to go to after selecting an option
//modifier is which section in the choice variable to modify
//changed[x] is to check if cut-ins have been changed
//q_text and q_name are queues where the text itself and names are
//q_namebox stores the size of the namebox
//qbox_y is what the y value of the question box is
//text_id is called upon textbox creation, and finds which text to use
//qbox_questions shows how many questions for multichoice boxes
//str_colored shows what the colored text is
//str_colorc is what color to use on special text
//str_inline is how many characters are in the current line of text
text_to_draw=0;
arrow_drawer=0;
chr_=0;
skipchr=0;
speed_mode=3;
sound_type=snd_voicemid;
str_edited="";
shaking=0;
view_xstart=view_xview[view_current];
view_ystart=view_yview[view_current];
namebox_size=0;
command=0;
sliding=1;
drawbox_y=62;
drawbox2_y=-50;
text_option=0;
option_text="";
goto_text=0;
changed[0]=0;
changed[1]=0;
modifier=0;
q_text=ds_queue_create();
q_name=ds_queue_create();
q_namesize=ds_queue_create();
qbox_y=278;
qbox_questions=0;
str_colored=0;
str_colorc=0;
str_inline=0;
//All variables past here are for the cut-in heads
//Initializing how many cut-ins are currently being used
//(up to 2 in this engine demo)
ci_count=0;
q_cicount=ds_queue_create();
//Initializing the cut-in IDs, flips, and x positions
ci_id[0]=0;
q_ciid[0]=ds_queue_create();
ci_xto[0]=0;
q_cixto[0]=ds_queue_create();
ci_xpos[0]=400;
ci_flip[0]=0;
q_ciflip[0]=ds_queue_create();
q_cichange[0]=ds_queue_create();
ci_id[1]=0;
q_ciid[1]=ds_queue_create();
ci_xto[1]=0;
q_cixto[1]=ds_queue_create();
ci_xpos[1]=400;
ci_flip[1]=0;
q_ciflip[1]=ds_queue_create();
q_cichange[1]=ds_queue_create();
alarm[2]=1; //This is so it doesn't break setting text_id upon creation through other objects
//DEBUG FEATURE, PLEASE IGNORE
//show_message(string(ds_queue_size(q_name)))

/*matt edit*/

image_xscale=room_width;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Delete the queues for memory purposes
ds_queue_destroy(q_name);
ds_queue_destroy(q_text);
ds_queue_destroy(q_namesize);
ds_queue_destroy(q_cicount);
ds_queue_destroy(q_ciid[0]);
ds_queue_destroy(q_cixto[0]);
ds_queue_destroy(q_ciflip[0]);
ds_queue_destroy(q_cichange[0]);
ds_queue_destroy(q_ciid[1]);
ds_queue_destroy(q_cixto[1]);
ds_queue_destroy(q_ciflip[1]);
ds_queue_destroy(q_cichange[1]);
/*
/////////////////////////TESTING ROOM PURPOSES
*/
ShouldIPlayTheNextCutscene();
/*
/////////////////////////
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_textbox(text_id);
//c tells how many boxes are in the current text
c=ds_queue_size(q_text);
//Init the namebox and string for first box
namebox_name=ds_queue_dequeue(q_name);
namebox_size=ds_queue_dequeue(q_namesize);
str_=ds_queue_dequeue(q_text);
ci_count=ds_queue_dequeue(q_cicount);
if (ci_count==1)
{
  ci_id[0]=ds_queue_dequeue(q_ciid[0]);
  ci_xpos[0]=400;
  ci_xto[0]=ds_queue_dequeue(q_cixto[0]);
  ci_flip[0]=ds_queue_dequeue(q_ciflip[0]);
}
if (ci_count==2)
{
  ci_id[0]=ds_queue_dequeue(q_ciid[0]);
  ci_xpos[0]=400;
  ci_xto[0]=ds_queue_dequeue(q_cixto[0]);
  ci_flip[0]=ds_queue_dequeue(q_ciflip[0]);
  ci_id[1]=ds_queue_dequeue(q_ciid[1]);
  ci_xpos[1]=400;
  ci_xto[1]=ds_queue_dequeue(q_cixto[1]);
  ci_flip[1]=ds_queue_dequeue(q_ciflip[1]);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (command==0)
{
  if (ci_count&gt;0)
  {
    if (ci_count==1)
    {
      if (ci_xto[0]==ci_xpos[0])
      {
        chr_+=1;
        str_inline+=1;
      }
      else
      {
        alarm[1]=2;
      }
    }
    else
    {
      if (ci_xto[0]==ci_xpos[0] and ci_xto[1]==ci_xpos[1])
      {
        chr_+=1;
        str_inline+=1;
      }
      else
      {
        alarm[1]=2;
      }
    }
  }
  else
  {
    chr_+=1;
    str_inline+=1;
  }
}
else
{
  command=0;
}
//if the currently drawn character is smaller than the lentgh of the current string
//[check the script "scr_charactercheck" for more info]
//
//if the currently drawn character is larger than or equal to the lentgh of the current string
//if the arrow is not being drawn
//draw the arrow
if (chr_&lt;string_length(str_edited))
{
  //speed_mode can be changed in-text
  scr_charactercheck();
  if (((speed_mode==3 and frac(chr_/4)==0) or (speed_mode==2 and frac(chr_/3)==0) or (speed_mode==1 and string_char_at(str_edited,chr_)!=" ")) and chr_&gt;0 and command==0)
  {
    sound_play(sound_type);
  }
}
else
{
  if (arrow_drawer==0)
  {
    arrow_drawer=2;
    alarm[0]=2;
  }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>arrow_drawer=1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//screen shake effect
if (shaking==1)
{
  view_xview[view_current]=view_xstart+choose(-2,-1,0,1,2);
  view_yview[view_current]=view_ystart+choose(-2,-1,0,1,2);
}
else
{
  view_xview[view_current]=view_xstart;
  view_yview[view_current]=view_ystart;
}
//textbox sliding
if (sliding==1)
{
  drawbox2_y+=1;
  if (drawbox_y&gt;38)
  {
    drawbox_y-=3;
  }
  else
  {
    if (drawbox_y&gt;6)
    {
      drawbox_y-=2;
    }
    else
    {
      drawbox_y-=1;
      if (drawbox_y==0)
      {
        sliding=0;
        alarm[1]=3;
        scr_stredit();
      }
    }
  }
}
if (sliding==-1)
{
  if (ci_count==0)
  {
    drawbox_y+=8;
    drawbox2_y-=6;
    if (drawbox_y&gt;=64)
    {
      instance_destroy();
    }
  }
  else
  {
    if (ci_count==1)
    {
      if (ci_xpos[0]&lt;160) //if a character is to the left of the middle of the screen
      {
        if (ci_xpos[0]&gt;-80)
        {
          ci_xpos[0]-=16;
        }
        else
        {
          drawbox_y+=8;
          drawbox2_y-=6;
          if (drawbox_y&gt;=64)
          {
            instance_destroy();
          }
        }
      }
      if (ci_xpos[0]&gt;=160) //if a character is to the right of the middle of the screen
      {
        if (ci_xpos[0]&lt;440)
        {
          ci_xpos[0]+=16;
        }
        else
        {
          drawbox_y+=8;
          drawbox2_y-=6;
          if (drawbox_y&gt;=64)
          {
            instance_destroy();
          }
        }
      }
    }
    if (ci_count==2)
    {
      if (ci_xpos[0]&lt;160) //if a character is to the left of the middle of the screen
      {
        if (ci_xpos[0]&gt;-80)
        {
          ci_xpos[0]-=16;
        }
        else
        {
          drawbox_y+=8;
          drawbox2_y-=6;
          if (drawbox_y&gt;=64)
          {
            instance_destroy();
          }
        }
      }
      if (ci_xpos[0]&gt;=160) //if a character is to the right of the middle of the screen
      {
        if (ci_xpos[0]&lt;440)
        {
          ci_xpos[0]+=16;
        }
        else
        {
          drawbox_y+=8;
          drawbox2_y-=6;
          if (drawbox_y&gt;=64)
          {
            instance_destroy();
          }
        }
      }
      if (ci_xpos[1]&lt;160) //if a character is to the left of the middle of the screen
      {
        if (ci_xpos[1]&gt;-80)
        {
          ci_xpos[1]-=16;
        }
        else
        {
          drawbox_y+=8;
          drawbox2_y-=6;
          if (drawbox_y&gt;=64)
          {
            instance_destroy();
          }
        }
      }
      if (ci_xpos[1]&gt;=160) //if a character is to the right of the middle of the screen
      {
        if (ci_xpos[1]&lt;440)
        {
          ci_xpos[1]+=16;
        }
        else
        {
          drawbox_y+=8;
          drawbox2_y-=6;
          if (drawbox_y&gt;=64)
          {
            instance_destroy();
          }
        }
      }
    }
  }
}
//moving the cut-ins
if (ci_count==1 and sliding==0)
{
  //cixpos0 right of xto
  if (ci_xpos[0]&gt;ci_xto[0])
  {
    if (ci_xpos[0]&lt;=ci_xto[0]+80)
    {
      if (ci_xpos[0]&lt;=ci_xto[0]+25)
      {
        if (ci_xpos[0]&lt;=ci_xto[0]+5)
        {
          ci_xpos[0]-=1;
        }
        else
        {
          ci_xpos[0]-=4;
        }
      }
      else
      {
        ci_xpos[0]-=8;
      }
    }
    else
    {
      ci_xpos[0]-=16;
    }
  }
  //cixpos0 left of xto
  if (ci_xpos[0]&lt;ci_xto[0])
  {
    if (ci_xpos[0]&gt;=ci_xto[0]-80)
    {
      if (ci_xpos[0]&gt;=ci_xto[0]-25)
      {
        if (ci_xpos[0]&gt;=ci_xto[0]-5)
        {
          ci_xpos[0]+=1;
        }
        else
        {
          ci_xpos[0]+=4;
        }
      }
      else
      {
        ci_xpos[0]+=8;
      }
    }
    else
    {
      ci_xpos[0]+=16;
    }
  }
}
if (ci_count==2 and sliding==0)
{
  //cixpos0 right of xto
  if (ci_xpos[0]&gt;ci_xto[0])
  {
    if (ci_xpos[0]&lt;=ci_xto[0]+80)
    {
      if (ci_xpos[0]&lt;=ci_xto[0]+25)
      {
        if (ci_xpos[0]&lt;=ci_xto[0]+5)
        {
          ci_xpos[0]-=1;
        }
        else
        {
          ci_xpos[0]-=4;
        }
      }
      else
      {
        ci_xpos[0]-=8;
      }
    }
    else
    {
      ci_xpos[0]-=16;
    }
  }
  //cixpos0 left of xto
  if (ci_xpos[0]&lt;ci_xto[0])
  {
    if (ci_xpos[0]&gt;=ci_xto[0]-80)
    {
      if (ci_xpos[0]&gt;=ci_xto[0]-25)
      {
        if (ci_xpos[0]&gt;=ci_xto[0]-5)
        {
          ci_xpos[0]+=1;
        }
        else
        {
          ci_xpos[0]+=4;
        }
      }
      else
      {
        ci_xpos[0]+=8;
      }
    }
    else
    {
      ci_xpos[0]+=16;
    }
  }
  //cixpos1 right of xto
  if (ci_xpos[1]&gt;ci_xto[1])
  {
    if (ci_xpos[1]&lt;=ci_xto[1]+80)
    {
      if (ci_xpos[1]&lt;=ci_xto[1]+25)
      {
        if (ci_xpos[1]&lt;=ci_xto[1]+5)
        {
          ci_xpos[1]-=1;
        }
        else
        {
          ci_xpos[1]-=4;
        }
      }
      else
      {
        ci_xpos[1]-=8;
      }
    }
    else
    {
      ci_xpos[1]-=16;
    }
  }
  //cixpos1 left of xto
  if (ci_xpos[1]&lt;ci_xto[1])
  {
    if (ci_xpos[1]&gt;=ci_xto[1]-80)
    {
      if (ci_xpos[1]&gt;=ci_xto[1]-25)
      {
        if (ci_xpos[1]&gt;=ci_xto[1]-5)
        {
          ci_xpos[1]+=1;
        }
        else
        {
          ci_xpos[1]+=4;
        }
      }
      else
      {
        ci_xpos[1]+=8;
      }
    }
    else
    {
      ci_xpos[1]+=16;
    }
  }
}
//moving the question box
if (text_option&gt;=2 and arrow_drawer==1)
{
  if (qbox_y&gt;64)
  {
    if (qbox_y&lt;120)
    {
      if (qbox_y&lt;70)
      {
        qbox_y-=1;
      }
      else
      {
        qbox_y-=3;
      }
    }
    else
    {
      qbox_y-=6;
    }
  }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (arrow_drawer==1 and text_option==0)
{ 
  //if the current line of text is larger than the last line
  //destroy self
  if (text_to_draw+2&gt;c)
  {
    sliding=-1;
    sound_play(snd_textboxclose);
  }
  else
  {
    //stop drawing the arrow
    arrow_drawer=0;
    //set the text to the next line
    text_to_draw+=1;
    //re-initialize the text printing
    chr_=0;
    skipchr=0;
    str_colorc=0;
    str_colored="";
    str_inline=0;
    //sets up the new command-free text line
    namebox_name=ds_queue_dequeue(q_name);
    namebox_size=ds_queue_dequeue(q_namesize);
    str_=ds_queue_dequeue(q_text);
    ci_count=ds_queue_dequeue(q_cicount);
    if (ci_count&gt;0)
    {
      if (ci_count==1)
      {
        ci_id[0]=ds_queue_dequeue(q_ciid[0]);
        changed[0]=ds_queue_dequeue(q_cichange[0]);
        if (changed[0]=1)
        {
          ci_xpos[0]=400;
          changed[0]=0;
        }
        ci_xto[0]=ds_queue_dequeue(q_cixto[0]);
        ci_flip[0]=ds_queue_dequeue(q_ciflip[0]);
      }
      if (ci_count==2)
      {
        ci_id[0]=ds_queue_dequeue(q_ciid[0]);
        changed[0]=ds_queue_dequeue(q_cichange[0]);
        if (changed[0]=1)
        {
          ci_xpos[0]=400;
          changed[0]=0;
        }
        ci_xto[0]=ds_queue_dequeue(q_cixto[0]);
        ci_flip[0]=ds_queue_dequeue(q_ciflip[0]);
        ci_id[1]=ds_queue_dequeue(q_ciid[1]);
        changed[1]=ds_queue_dequeue(q_cichange[1]);
        if (changed[1]=1)
        {
          ci_xpos[1]=400;
          changed[1]=0;
        }
        ci_xto[1]=ds_queue_dequeue(q_cixto[1]);
        ci_flip[1]=ds_queue_dequeue(q_ciflip[1]);
      }
    }
    scr_stredit();
    sound_play(snd_click);
    alarm[1]=1;
  }
}
else
{
  if (arrow_drawer==1 and text_option&gt;=1)
  {
    if (text_option&gt;1 and qbox_y&gt;64)
    {
      exit;
    }
    global.text_choices=string_delete(global.text_choices,modifier,1);
    switch(text_option)
    {
      case 1: global.text_choices=string_insert("1",global.text_choices,modifier); break;
      case 2: global.text_choices=string_insert("2",global.text_choices,modifier); break;
      case 3: global.text_choices=string_insert("3",global.text_choices,modifier); break;
      case 4: global.text_choices=string_insert("4",global.text_choices,modifier); break;
      case 5: global.text_choices=string_insert("5",global.text_choices,modifier); break;
      case 6: global.text_choices=string_insert("6",global.text_choices,modifier); break;
      case 7: global.text_choices=string_insert("7",global.text_choices,modifier); break;
    }
    text_id=goto_text[text_option-1];
    text_option=0;
    qbox_y=278;
    //get the new text
    scr_textbox(text_id);
    c=ds_queue_size(q_text);
    //stop drawing the arrow
    arrow_drawer=0;
    //set the text to the beginning
    text_to_draw=0;
    //re-initialize the text printing
    chr_=0;
    skipchr=0;
    str_colorc=0;
    str_colored="";
    str_inline=0;
    //sets up the new command-free text line
    namebox_name=ds_queue_dequeue(q_name);
    str_=ds_queue_dequeue(q_text);
    ci_count=ds_queue_dequeue(q_cicount);
    if (ci_count&gt;0)
    {
      if (ci_count==1)
      {
        ci_id[0]=ds_queue_dequeue(q_ciid[0]);
        changed[0]=ds_queue_dequeue(q_cichange[0]);
        if (changed[0]=1)
        {
          ci_xpos[0]=400;
          changed[0]=0;
        }
        ci_xto[0]=ds_queue_dequeue(q_cixto[0]);
        ci_flip[0]=ds_queue_dequeue(q_ciflip[0]);
      }
      if (ci_count==2)
      {
        ci_id[0]=ds_queue_dequeue(q_ciid[0]);
        changed[0]=ds_queue_dequeue(q_cichange[0]);
        if (changed[0]=1)
        {
          ci_xpos[0]=400;
          changed[0]=0;
        }
        ci_xto[0]=ds_queue_dequeue(q_cixto[0]);
        ci_flip[0]=ds_queue_dequeue(q_ciflip[0]);
        ci_id[1]=ds_queue_dequeue(q_ciid[1]);
        changed[1]=ds_queue_dequeue(q_cichange[1]);
        if (changed[1]=1)
        {
          ci_xpos[1]=400;
          changed[1]=0;
        }
        ci_xto[1]=ds_queue_dequeue(q_cixto[1]);
        ci_flip[1]=ds_queue_dequeue(q_ciflip[1]);
      }
    }
    scr_stredit();
    sound_play(snd_click);
    alarm[1]=1;
  }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//draw the textbox.
//
//WOW HIGHLY INFORMATIVE.
//
draw_set_font(fnt_textbox);
draw_set_halign(fa_left);
draw_set_color(c_white);
if (ci_count&gt;0)
{
  draw_sprite_ext(ci_id[0],0,view_xview[view_current]+ci_xpos[0],view_yview[view_current],ci_flip[0],1,0,c_white,1);
  if (ci_count&gt;1)
  {
    draw_sprite_ext(ci_id[1],0,view_xview[view_current]+ci_xpos[1],view_yview[view_current],ci_flip[1],1,0,c_white,1);
  }
}
if (text_option&gt;2)
{
  scr_drawqbox()
}
draw_sprite_stretched(spr_textbox,0,view_xview[view_current],view_yview[view_current]+(room_height/8)*6+drawbox_y,room_width,sprite_height*2);
draw_sprite_stretched(spr_textbox,0,view_xview[view_current],view_yview[view_current]+drawbox2_y,room_width,sprite_height);
draw_sprite(spr_namebox,namebox_size,view_xview[view_current],view_yview[view_current]+((room_height/8)*6)-12+drawbox_y);
if (alarm[2]&lt;0) //This is so it doesn't break setting text_id upon creation through other objects
{
  draw_text(view_xview[view_current],view_yview[view_current]+((room_height/8)*6)-12+drawbox_y,namebox_name);
}
draw_text(view_xview[view_current],view_yview[view_current]+((room_height/8)*6)+drawbox_y,string_copy(str_edited,1,chr_));
if (str_colorc&gt;0)
{
  draw_set_color(str_colorc);
  draw_text(view_xview[view_current],view_yview[view_current]+(room_height/8)*6+drawbox_y,string_copy(str_colored,1,str_inline+string_count("#",string_copy(str_edited,1,chr_))));
}
//draws the arrow after text is finished being written
if (arrow_drawer==1)
{
  if (text_option&gt;0)
  {
    if (text_option&lt;3)
    {
      if (text_option==1)
      {
        draw_set_color(make_color_rgb(0,184,0));
        draw_text(view_xview[view_current],view_yview[view_current]+drawbox_y,"##  - "+option_text[0]);
        draw_set_color(c_white);
        draw_text(view_xview[view_current],view_yview[view_current]+drawbox_y,"###  - "+option_text[1]);
      }
      else
      {
        draw_text(view_xview[view_current],view_yview[view_current]+drawbox_y,"##  - "+option_text[0]);
        draw_set_color(make_color_rgb(0,184,0));
        draw_text(view_xview[view_current],view_yview[view_current]+drawbox_y,"###  - "+option_text[1]);
        draw_set_color(c_white);
      }
    }
  }
  else
  {
    draw_sprite(spr_textboxarrow,0,view_xview[view_current]+310,view_yview[view_current]+232);
  }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
